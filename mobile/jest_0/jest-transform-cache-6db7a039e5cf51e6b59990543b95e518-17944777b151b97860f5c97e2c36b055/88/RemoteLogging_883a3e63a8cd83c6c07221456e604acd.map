{"version":3,"sources":["RemoteLogging.js"],"names":["__waitForEmptyLogQueueAsync","_sessionId","UUID","create","toString","_logQueue","_transportEventEmitter","EventEmitter","_logCounter","_isSendingLogs","_completionPromise","_resolveCompletion","enqueueRemoteLogAsync","level","additionalFields","data","_isReactNativeWarning","length","warning","lines","split","test","LogSerialization","serializeLogDataAsync","body","includesStack","push","count","_sendRemoteLogsAsync","catch","setImmediate","error","batch","splice","logUrl","Constants","manifest","_sendNextLogBatchAsync","response","fetch","method","headers","Connection","Accept","deviceId","deviceName","JSON","stringify","emit","success","status","Error","addTransportErrorListener","listener","addListener","startsWith","Promise","resolve"],"mappings":"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","file":"RemoteLogging.js","sourcesContent":["// @flow\n\nimport { EventEmitter, type EventSubscription } from 'fbemitter';\nimport invariant from 'invariant';\nimport UUID from 'uuid-js';\n\nimport LogSerialization from './LogSerialization';\nimport Constants from '../Constants';\n\nexport type LogLevel = 'debug' | 'info' | 'warn' | 'error';\n\ntype LogEntry = {\n  count: number,\n  level: LogLevel,\n  body: Array<LogData>,\n  includesStack: boolean,\n  groupDepth?: number,\n} & LogEntryFields;\n\nexport type LogEntryFields = {\n  shouldHide?: boolean,\n  groupDepth?: number,\n  groupCollapsed?: boolean,\n};\n\nexport type LogData = string | {| message: string, stack: string |};\n\ntype TransportErrorListener = ({ error: Error, response?: Response }) => void;\n\nconst _sessionId = UUID.create().toString();\nconst _logQueue: Array<LogEntry> = [];\nconst _transportEventEmitter = new EventEmitter();\n\nlet _logCounter = 0;\nlet _isSendingLogs = false;\nlet _completionPromise: ?Promise<void>;\nlet _resolveCompletion: ?() => void;\n\nasync function enqueueRemoteLogAsync(\n  level: LogLevel,\n  additionalFields: LogEntryFields,\n  data: Array<mixed>\n): Promise<void> {\n  if (_isReactNativeWarning(data)) {\n    // Remove the stack trace from the warning message since we'll capture our own\n    invariant(data.length > 0, `Warnings must include log arguments`);\n    invariant(typeof data[0] === 'string', `The log argument for a warning must be a string`);\n\n    const warning = data[0];\n    const lines = warning.split('\\n');\n    if (lines.length > 1 && /^\\s+in /.test(lines[1])) {\n      data[0] = lines[0];\n    }\n  }\n\n  let { body, includesStack } = await LogSerialization.serializeLogDataAsync(data, level);\n\n  _logQueue.push({\n    count: _logCounter++,\n    level,\n    body,\n    includesStack,\n    ...additionalFields,\n  });\n\n  // Send the logs asynchronously (system errors are emitted with transport error events) and throw an uncaught error\n  _sendRemoteLogsAsync().catch(error => {\n    setImmediate(() => {\n      throw error;\n    });\n  });\n}\n\nasync function _sendRemoteLogsAsync(): Promise<void> {\n  if (_isSendingLogs || !_logQueue.length) {\n    return;\n  }\n\n  // Our current transport policy is to send all of the pending log messages in one batch. If we opt\n  // for another policy (ex: throttling) this is where to to implement it.\n  let batch = _logQueue.splice(0);\n\n  let { logUrl } = Constants.manifest;\n  invariant(typeof logUrl === 'string', 'The Expo project manifest must specify `logUrl`');\n\n  _isSendingLogs = true;\n  try {\n    await _sendNextLogBatchAsync(batch, logUrl);\n  } finally {\n    _isSendingLogs = false;\n  }\n\n  if (_logQueue.length) {\n    return _sendRemoteLogsAsync();\n  } else if (_resolveCompletion) {\n    _resolveCompletion();\n  }\n}\n\nasync function _sendNextLogBatchAsync(batch: Array<LogEntry>, logUrl: string): Promise<void> {\n  let response;\n  try {\n    response = await fetch(logUrl, {\n      method: 'POST',\n      headers: {\n        'Content-Type': 'application/json',\n        Connection: 'keep-alive',\n        'Proxy-Connection': 'keep-alive',\n        Accept: 'application/json',\n        'Device-Id': Constants.deviceId,\n        'Device-Name': Constants.deviceName,\n        'Session-Id': _sessionId,\n      },\n      body: JSON.stringify(batch),\n    });\n  } catch (error) {\n    _transportEventEmitter.emit('error', { error });\n    return;\n  }\n\n  let success = response.status >= 200 && response.status < 300;\n  if (!success) {\n    _transportEventEmitter.emit('error', {\n      error: new Error(`An HTTP error occurred when sending remote logs`),\n      response,\n    });\n  }\n}\n\nfunction addTransportErrorListener(listener: TransportErrorListener): EventSubscription {\n  return _transportEventEmitter.addListener('error', listener);\n}\n\nfunction _isReactNativeWarning(data: Array<mixed>): boolean {\n  // NOTE: RN does the same thing internally for YellowBox\n  return data.length === 1 && typeof data[0] === 'string' && data[0].startsWith('Warning: ');\n}\n\nexport default {\n  enqueueRemoteLogAsync,\n  addTransportErrorListener,\n};\n\n/**\n * Returns a promise that resolves when all entries in the log queue have been sent. This method is\n * intended for testing only.\n */\nexport function __waitForEmptyLogQueueAsync(): Promise<void> {\n  if (_completionPromise) {\n    return _completionPromise;\n  }\n\n  if (!_isSendingLogs && !_logQueue.length) {\n    return Promise.resolve();\n  }\n\n  _completionPromise = new Promise(resolve => {\n    _resolveCompletion = () => {\n      invariant(!_isSendingLogs, `Must not be sending logs at completion`);\n      invariant(!_logQueue.length, `Log queue must be empty at completion`);\n\n      _completionPromise = null;\n      _resolveCompletion = null;\n\n      resolve();\n    };\n  });\n  return _completionPromise;\n}\n"]}