{"version":3,"sources":["Notifications.js"],"names":["ExponentNotifications","NativeModules","_emitter","_initialNotification","_maybeInitEmitter","EventEmitter","DeviceEventEmitter","addListener","_emitNotification","notification","JSON","parse","data","e","emit","_processNotification","hasOwnProperty","count","Platform","OS","android","ios","_validateNotification","title","body","ASYNC_STORAGE_PREFIX","IS_USING_NEW_BINARY","createChannel","_legacyReadChannel","id","AsyncStorage","getItem","channelString","_legacyDeleteChannel","removeItem","clear","callback","getAllKeys","keys","result","length","filteredKeys","filter","key","startsWith","multiRemove","_legacySaveChannel","channel","setItem","stringify","_setInitialNotification","getExpoPushTokenAsync","getExponentPushTokenAsync","getDevicePushTokenAsync","createChannelAndroidAsync","console","warn","Promise","resolve","deleteChannelAndroidAsync","deleteChannel","presentLocalNotificationAsync","presentLocalNotification","_channel","channelId","presentLocalNotificationWithChannel","sound","priority","vibrate","scheduleLocalNotificationAsync","options","now","Date","time","timeAsDateObj","Error","getTime","intervalMs","repeat","validOptions","Set","has","Number","isInteger","scheduleLocalNotification","scheduleLocalNotificationWithChannel","dismissNotificationAsync","notificationId","dismissNotification","dismissAllNotificationsAsync","dismissAllNotifications","cancelScheduledNotificationAsync","cancelScheduledNotification","cancelAllScheduledNotificationsAsync","cancelAllScheduledNotifications","listener","initialNotification","setTimeout","getBadgeNumberAsync","setBadgeNumberAsync","number"],"mappings":"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","file":"Notifications.js","sourcesContent":["// @flow\n\nimport { EventEmitter, EventSubscription } from 'fbemitter';\n\nimport invariant from 'invariant';\nimport warning from 'fbjs/lib/warning';\n\nimport { AsyncStorage, DeviceEventEmitter, NativeModules, Platform } from 'react-native';\n\nconst { ExponentNotifications } = NativeModules;\n\ntype Notification = {\n  origin: 'selected' | 'received',\n  data: any,\n  remote: boolean,\n  isMultiple: boolean,\n};\n\ntype LocalNotification = {\n  title: string,\n  // How should we deal with body being required on iOS but not on Android?\n  body?: string,\n  data?: any,\n  ios?: {\n    sound?: boolean,\n  },\n  android?: {\n    channelId?: string,\n    icon?: string,\n    color?: string,\n    sticky?: boolean,\n    link?: string,\n    // DEPRECATED:\n    sound?: boolean,\n    vibrate?: boolean | Array<number>,\n    priority: string,\n  },\n};\n\ntype Channel = {\n  name: string,\n  description?: string,\n  priority?: string,\n  sound?: boolean,\n  vibrate?: boolean | Array<number>,\n  badge?: boolean,\n};\n\n// Android assigns unique number to each notification natively.\n// Since that's not supported on iOS, we generate an unique string.\ntype LocalNotificationId = string | number;\n\nlet _emitter;\nlet _initialNotification;\n\nfunction _maybeInitEmitter() {\n  if (!_emitter) {\n    _emitter = new EventEmitter();\n    DeviceEventEmitter.addListener('Exponent.notification', _emitNotification);\n  }\n}\n\nfunction _emitNotification(notification) {\n  if (typeof notification === 'string') {\n    notification = JSON.parse(notification);\n  }\n\n  /* Don't mutate the original notification */\n  notification = { ...notification };\n\n  if (typeof notification.data === 'string') {\n    try {\n      notification.data = JSON.parse(notification.data);\n    } catch (e) {\n      // It's actually just a string, that's fine\n    }\n  }\n\n  _emitter.emit('notification', notification);\n}\n\nfunction _processNotification(notification) {\n  notification = Object.assign({}, notification);\n\n  if (!notification.data) {\n    notification.data = {};\n  }\n\n  if (notification.hasOwnProperty('count')) {\n    delete notification.count;\n  }\n\n  // Delete any Android properties on iOS and merge the iOS properties on root notification object\n  if (Platform.OS === 'ios') {\n    if (notification.android) {\n      delete notification.android;\n    }\n\n    if (notification.ios) {\n      notification = Object.assign(notification, notification.ios);\n      delete notification.ios;\n    }\n  }\n\n  // Delete any iOS properties on Android and merge the Android properties on root notification\n  // object\n  if (Platform.OS === 'android') {\n    if (notification.ios) {\n      delete notification.ios;\n    }\n\n    if (notification.android) {\n      notification = Object.assign(notification, notification.android);\n      delete notification.android;\n    }\n  }\n\n  return notification;\n}\n\nfunction _validateNotification(notification) {\n  if (Platform.OS === 'ios') {\n    invariant(\n      !!notification.title && !!notification.body,\n      'Local notifications on iOS require both a title and a body'\n    );\n  } else if (Platform.OS === 'android') {\n    invariant(!!notification.title, 'Local notifications on Android require a title');\n  }\n}\n\nlet ASYNC_STORAGE_PREFIX = '__expo_internal_channel_';\n// TODO: remove this before releasing\n// this will always be `true` for SDK 28+\nlet IS_USING_NEW_BINARY = typeof ExponentNotifications.createChannel === 'function';\n\nasync function _legacyReadChannel(id: string): Promise<Channel | null> {\n  try {\n    let channelString = await AsyncStorage.getItem(`${ASYNC_STORAGE_PREFIX}${id}`);\n    if (channelString) {\n      return JSON.parse(channelString);\n    }\n  } catch (e) {}\n  return null;\n}\n\nfunction _legacyDeleteChannel(id: string): Promise<void> {\n  return AsyncStorage.removeItem(`${ASYNC_STORAGE_PREFIX}${id}`);\n}\n\nif (Platform.OS === 'android') {\n  AsyncStorage.clear = async function(callback?: ?(error: ?Error) => void): Promise {\n    try {\n      let keys = await AsyncStorage.getAllKeys();\n      let result = null;\n      if (keys && keys.length) {\n        let filteredKeys = keys.filter(key => !key.startsWith(ASYNC_STORAGE_PREFIX));\n        result = await AsyncStorage.multiRemove(filteredKeys);\n      }\n      callback && callback(result);\n      return result;\n    } catch (e) {\n      callback && callback(e);\n      throw e;\n    }\n  };\n}\n\n// This codepath will never be triggered in SDK 28 and above\n// TODO: remove before releasing\nfunction _legacySaveChannel(id: string, channel: Channel): Promise<void> {\n  return AsyncStorage.setItem(`${ASYNC_STORAGE_PREFIX}${id}`, JSON.stringify(channel));\n}\n\nexport default {\n  /* Only used internally to initialize the notification from top level props */\n  _setInitialNotification(notification: Notification) {\n    _initialNotification = notification;\n  },\n\n  /* Re-export */\n  getExpoPushTokenAsync(): Promise<string> {\n    return ExponentNotifications.getExponentPushTokenAsync();\n  },\n\n  /* Re-export, we can add flow here if we want as well */\n  getDevicePushTokenAsync: ExponentNotifications.getDevicePushTokenAsync,\n\n  createChannelAndroidAsync(id: string, channel: Channel): Promise<void> {\n    if (Platform.OS === 'ios') {\n      console.warn('createChannelAndroidAsync(...) has no effect on iOS');\n      return Promise.resolve();\n    }\n    // This codepath will never be triggered in SDK 28 and above\n    // TODO: remove before releasing\n    if (!IS_USING_NEW_BINARY) {\n      return _legacySaveChannel(id, channel);\n    }\n    return ExponentNotifications.createChannel(id, channel);\n  },\n\n  deleteChannelAndroidAsync(id: string): Promise<void> {\n    if (Platform.OS === 'ios') {\n      console.warn('deleteChannelAndroidAsync(...) has no effect on iOS');\n      return Promise.resolve();\n    }\n    // This codepath will never be triggered in SDK 28 and above\n    // TODO: remove before releasing\n    if (!IS_USING_NEW_BINARY) {\n      return Promise.resolve();\n    }\n    return ExponentNotifications.deleteChannel(id);\n  },\n\n  /* Shows a notification instantly */\n  async presentLocalNotificationAsync(\n    notification: LocalNotification\n  ): Promise<LocalNotificationId> {\n    _validateNotification(notification);\n    notification = _processNotification(notification);\n\n    if (Platform.OS === 'ios') {\n      return ExponentNotifications.presentLocalNotification(notification);\n    } else {\n      let _channel;\n      if (notification.channelId) {\n        _channel = await _legacyReadChannel(notification.channelId);\n      }\n\n      if (IS_USING_NEW_BINARY) {\n        // delete the legacy channel from AsyncStorage so this codepath isn't triggered anymore\n        _legacyDeleteChannel(notification.channelId);\n        return ExponentNotifications.presentLocalNotificationWithChannel(notification, _channel);\n      } else {\n        // TODO: remove this codepath before releasing, it will never be triggered on SDK 28+\n        // channel does not actually exist, so add its settings to the individual notification\n        if (_channel) {\n          notification.sound = _channel.sound;\n          notification.priority = _channel.priority;\n          notification.vibrate = _channel.vibrate;\n        }\n        return ExponentNotifications.presentLocalNotification(notification);\n      }\n    }\n  },\n\n  /* Schedule a notification at a later date */\n  async scheduleLocalNotificationAsync(\n    notification: LocalNotification,\n    options: {\n      time?: Date | number,\n      repeat?: 'minute' | 'hour' | 'day' | 'week' | 'month' | 'year',\n      intervalMs?: number,\n    } = {}\n  ): Promise<LocalNotificationId> {\n    // set now at the beginning of the method, to prevent potential weird warnings when we validate\n    // options.time later on\n    const now = Date.now();\n\n    // Validate and process the notification data\n    _validateNotification(notification);\n    notification = _processNotification(notification);\n\n    // Validate `options.time`\n    if (options.time) {\n      let timeAsDateObj = null;\n      if (options.time && typeof options.time === 'number') {\n        timeAsDateObj = new Date(options.time);\n        // god, JS is the worst\n        if (((timeAsDateObj: any): string) === 'Invalid Date') {\n          timeAsDateObj = null;\n        }\n      } else if (options.time && options.time instanceof Date) {\n        timeAsDateObj = options.time;\n      }\n\n      // If we couldn't convert properly, throw an error\n      if (!timeAsDateObj) {\n        throw new Error(\n          `Provided value for \"time\" is invalid. Please verify that it's either a number representing Unix Epoch time in milliseconds, or a valid date object.`\n        );\n      }\n\n      // If someone passes in a value that is too small, say, by an order of 1000 (it's common to\n      // accidently pass seconds instead of ms), display a warning.\n      warning(\n        timeAsDateObj >= now,\n        `Provided value for \"time\" is before the current date. Did you possibly pass number of seconds since Unix Epoch instead of number of milliseconds?`\n      );\n\n      // If iOS, pass time as milliseconds\n      if (Platform.OS === 'ios') {\n        options = {\n          ...options,\n          time: timeAsDateObj.getTime(),\n        };\n      } else {\n        options = {\n          ...options,\n          time: timeAsDateObj,\n        };\n      }\n    }\n\n    if (options.intervalMs != null && options.repeat != null) {\n      throw new Error(`Pass either the \"repeat\" option or \"intervalMs\" option, not both`);\n    }\n\n    // Validate options.repeat\n    if (options.repeat != null) {\n      const validOptions = new Set(['minute', 'hour', 'day', 'week', 'month', 'year']);\n      if (!validOptions.has(options.repeat)) {\n        throw new Error(\n          `Pass one of ['minute', 'hour', 'day', 'week', 'month', 'year'] as the value for the \"repeat\" option`\n        );\n      }\n    }\n\n    if (options.intervalMs != null) {\n      if (Platform.OS === 'ios') {\n        throw new Error(`The \"intervalMs\" option is not supported on iOS`);\n      }\n\n      if (options.intervalMs <= 0 || !Number.isInteger(options.intervalMs)) {\n        throw new Error(\n          `Pass an integer greater than zero as the value for the \"intervalMs\" option`\n        );\n      }\n    }\n\n    if (Platform.OS === 'ios') {\n      return ExponentNotifications.scheduleLocalNotification(notification, options);\n    } else {\n      let _channel;\n      if (notification.channelId) {\n        _channel = await _legacyReadChannel(notification.channelId);\n      }\n\n      if (IS_USING_NEW_BINARY) {\n        // delete the legacy channel from AsyncStorage so this codepath isn't triggered anymore\n        _legacyDeleteChannel(notification.channelId);\n        return ExponentNotifications.scheduleLocalNotificationWithChannel(\n          notification,\n          options,\n          _channel\n        );\n      } else {\n        // TODO: remove this codepath before releasing, it will never be triggered on SDK 28+\n        // channel does not actually exist, so add its settings to the individual notification\n        if (_channel) {\n          notification.sound = _channel.sound;\n          notification.priority = _channel.priority;\n          notification.vibrate = _channel.vibrate;\n        }\n        return ExponentNotifications.scheduleLocalNotification(notification, options);\n      }\n    }\n  },\n\n  /* Dismiss currently shown notification with ID (Android only) */\n  async dismissNotificationAsync(notificationId: LocalNotificationId): Promise<void> {\n    if (Platform.OS === 'android') {\n      return ExponentNotifications.dismissNotification(notificationId);\n    } else {\n      throw new Error('Dismissing notifications is not supported on iOS');\n    }\n  },\n\n  /* Dismiss all currently shown notifications (Android only) */\n  async dismissAllNotificationsAsync(): Promise<void> {\n    if (Platform.OS === 'android') {\n      return ExponentNotifications.dismissAllNotifications();\n    } else {\n      throw new Error('Dismissing notifications is not supported on iOS');\n    }\n  },\n\n  /* Cancel scheduled notification notification with ID */\n  cancelScheduledNotificationAsync(notificationId: LocalNotificationId): Promise<void> {\n    return ExponentNotifications.cancelScheduledNotification(notificationId);\n  },\n\n  /* Cancel all scheduled notifications */\n  cancelAllScheduledNotificationsAsync(): Promise<void> {\n    return ExponentNotifications.cancelAllScheduledNotifications();\n  },\n\n  /* Primary public api */\n  addListener(listener: Function): EventSubscription {\n    _maybeInitEmitter();\n\n    if (_initialNotification) {\n      const initialNotification = _initialNotification;\n      _initialNotification = null;\n      setTimeout(() => {\n        _emitNotification(initialNotification);\n      }, 0);\n    }\n\n    return _emitter.addListener('notification', listener);\n  },\n\n  async getBadgeNumberAsync(): Promise<number> {\n    if (!ExponentNotifications.getBadgeNumberAsync) {\n      return 0;\n    }\n    return ExponentNotifications.getBadgeNumberAsync();\n  },\n\n  async setBadgeNumberAsync(number: number): Promise<void> {\n    if (!ExponentNotifications.setBadgeNumberAsync) {\n      return;\n    }\n    return ExponentNotifications.setBadgeNumberAsync(number);\n  },\n};\n"]}