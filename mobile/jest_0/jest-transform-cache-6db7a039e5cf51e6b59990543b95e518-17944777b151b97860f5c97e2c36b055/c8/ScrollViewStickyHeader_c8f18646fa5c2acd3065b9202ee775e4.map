{"version":3,"sources":["ScrollViewStickyHeader.js"],"names":["AnimatedImplementation","require","React","StyleSheet","View","AnimatedView","createAnimatedComponent","ScrollViewStickyHeader","state","measured","layoutY","layoutHeight","nextHeaderLayoutY","props","_onLayout","setState","event","nativeEvent","layout","y","height","onLayout","child","Children","only","children","inverted","scrollViewHeight","inputRange","outputRange","stickStartPoint","push","collisionPoint","translateY","scrollAnimatedValue","interpolate","style","styles","header","transform","cloneElement","fill","undefined","Component","create","zIndex","flex","module","exports"],"mappings":"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","file":"ScrollViewStickyHeader.js","sourcesContent":["/**\n * Copyright (c) 2015-present, Facebook, Inc.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n * @providesModule ScrollViewStickyHeader\n * @flow\n * @format\n */\n'use strict';\n\nconst AnimatedImplementation = require('AnimatedImplementation');\nconst React = require('React');\nconst StyleSheet = require('StyleSheet');\nconst View = require('View');\n\nimport type {LayoutEvent} from 'CoreEventTypes';\n\nconst AnimatedView = AnimatedImplementation.createAnimatedComponent(View);\n\ntype Props = {\n  children?: React.Element<any>,\n  nextHeaderLayoutY: ?number,\n  onLayout: (event: LayoutEvent) => void,\n  scrollAnimatedValue: AnimatedImplementation.Value,\n  // Will cause sticky headers to stick at the bottom of the ScrollView instead\n  // of the top.\n  inverted: ?boolean,\n  // The height of the parent ScrollView. Currently only set when inverted.\n  scrollViewHeight: ?number,\n};\n\ntype State = {\n  measured: boolean,\n  layoutY: number,\n  layoutHeight: number,\n  nextHeaderLayoutY: ?number,\n};\n\nclass ScrollViewStickyHeader extends React.Component<Props, State> {\n  state = {\n    measured: false,\n    layoutY: 0,\n    layoutHeight: 0,\n    nextHeaderLayoutY: this.props.nextHeaderLayoutY,\n  };\n\n  setNextHeaderY(y: number) {\n    this.setState({nextHeaderLayoutY: y});\n  }\n\n  _onLayout = event => {\n    this.setState({\n      measured: true,\n      layoutY: event.nativeEvent.layout.y,\n      layoutHeight: event.nativeEvent.layout.height,\n    });\n\n    this.props.onLayout(event);\n    const child = React.Children.only(this.props.children);\n    if (child.props.onLayout) {\n      child.props.onLayout(event);\n    }\n  };\n\n  render() {\n    const {inverted, scrollViewHeight} = this.props;\n    const {measured, layoutHeight, layoutY, nextHeaderLayoutY} = this.state;\n    const inputRange: Array<number> = [-1, 0];\n    const outputRange: Array<number> = [0, 0];\n\n    if (measured) {\n      if (inverted) {\n        // The interpolation looks like:\n        // - Negative scroll: no translation\n        // - `stickStartPoint` is the point at which the header will start sticking.\n        //   It is calculated using the ScrollView viewport height so it is a the bottom.\n        // - Headers that are in the initial viewport will never stick, `stickStartPoint`\n        //   will be negative.\n        // - From 0 to `stickStartPoint` no translation. This will cause the header\n        //   to scroll normally until it reaches the top of the scroll view.\n        // - From `stickStartPoint` to when the next header y hits the bottom edge of the header: translate\n        //   equally to scroll. This will cause the header to stay at the top of the scroll view.\n        // - Past the collision with the next header y: no more translation. This will cause the\n        //   header to continue scrolling up and make room for the next sticky header.\n        //   In the case that there is no next header just translate equally to\n        //   scroll indefinitely.\n        if (scrollViewHeight != null) {\n          const stickStartPoint = layoutY + layoutHeight - scrollViewHeight;\n          if (stickStartPoint > 0) {\n            inputRange.push(stickStartPoint);\n            outputRange.push(0);\n            inputRange.push(stickStartPoint + 1);\n            outputRange.push(1);\n            // If the next sticky header has not loaded yet (probably windowing) or is the last\n            // we can just keep it sticked forever.\n            const collisionPoint =\n              (nextHeaderLayoutY || 0) - layoutHeight - scrollViewHeight;\n            if (collisionPoint > stickStartPoint) {\n              inputRange.push(collisionPoint, collisionPoint + 1);\n              outputRange.push(\n                collisionPoint - stickStartPoint,\n                collisionPoint - stickStartPoint,\n              );\n            }\n          }\n        }\n      } else {\n        // The interpolation looks like:\n        // - Negative scroll: no translation\n        // - From 0 to the y of the header: no translation. This will cause the header\n        //   to scroll normally until it reaches the top of the scroll view.\n        // - From header y to when the next header y hits the bottom edge of the header: translate\n        //   equally to scroll. This will cause the header to stay at the top of the scroll view.\n        // - Past the collision with the next header y: no more translation. This will cause the\n        //   header to continue scrolling up and make room for the next sticky header.\n        //   In the case that there is no next header just translate equally to\n        //   scroll indefinitely.\n        inputRange.push(layoutY);\n        outputRange.push(0);\n        // If the next sticky header has not loaded yet (probably windowing) or is the last\n        // we can just keep it sticked forever.\n        const collisionPoint = (nextHeaderLayoutY || 0) - layoutHeight;\n        if (collisionPoint >= layoutY) {\n          inputRange.push(collisionPoint, collisionPoint + 1);\n          outputRange.push(collisionPoint - layoutY, collisionPoint - layoutY);\n        } else {\n          inputRange.push(layoutY + 1);\n          outputRange.push(1);\n        }\n      }\n    }\n\n    const translateY = this.props.scrollAnimatedValue.interpolate({\n      inputRange,\n      outputRange,\n    });\n    const child = React.Children.only(this.props.children);\n\n    return (\n      <AnimatedView\n        collapsable={false}\n        onLayout={this._onLayout}\n        style={[child.props.style, styles.header, {transform: [{translateY}]}]}>\n        {React.cloneElement(child, {\n          style: styles.fill, // We transfer the child style to the wrapper.\n          onLayout: undefined, // we call this manually through our this._onLayout\n        })}\n      </AnimatedView>\n    );\n  }\n}\n\nconst styles = StyleSheet.create({\n  header: {\n    zIndex: 10,\n  },\n  fill: {\n    flex: 1,\n  },\n});\n\nmodule.exports = ScrollViewStickyHeader;\n"]}