{"version":3,"sources":["PrivateFeed.js"],"names":["registerForPushNotificationsAsync","Expo","Permissions","getAsync","NOTIFICATIONS","existingStatus","status","finalStatus","askAsync","Promise","Notifications","getExpoPushTokenAsync","token","resolve","then","tk","Feed","listener","addListener","listen","props","origin","data","console","log","_onRefresh","setState","refreshing","componentDidMount","state","url","NOTIFICATIONS_API","fetch","response","json","responseJson","isLoading","dataSource","catch","error","styles","item","item2","text1","title","uri","image","width","height","text","message","index","id","toString","React","Component","StyleSheet","create","backgroundColor","margin","shadowColor","shadowOpacity","shadowRadius","shadowOffset","elevation","alignItems","justifyContent","flexGrow","padding","borderRadius","color","fontWeight"],"mappings":"ilBAAA,4B,2CACA,yCACA,qC,i4BAGA,QAAeA,kCAAf,uPAC2CC,KAAKC,WAAL,CAAiBC,QAAjB,CACvCF,KAAKC,WAAL,CAAiBE,aADsB,CAD3C,4BACkBC,cADlB,MACUC,MADV,CAIMC,WAJN,CAIoBF,cAJpB,MAQMA,iBAAmB,SARzB,2EAW6BJ,KAAKC,WAAL,CAAiBM,QAAjB,CAA0BP,KAAKC,WAAL,CAAiBE,aAA3C,CAX7B,6BAWYE,MAXZ,OAWYA,MAXZ,CAYIC,YAAcD,MAAd,CAZJ,aAgBMC,cAAgB,SAhBtB,+GAoBiBE,OApBjB,kDAqB4BR,KAAKS,aAAL,CAAmBC,qBAAnB,EArB5B,sBAqBcC,KArBd,2BAsBU,kBAAKA,MAAL,EAtBV,yBAqBKC,OArBL,+BAsBKC,IAtBL,8FAoBMC,EApBN,+CAuBSA,EAvBT,2D,GA4BqBC,K,6IAEE,CAEnB,KAAKC,QAAL,CAAgBhB,KAAKS,aAAL,CAAmBQ,WAAnB,CAA+B,KAAKC,MAApC,CAAhB,CACD,C,mEACsB,CACrB,KAAKF,QAAL,EAAiBhB,KAAKS,aAAL,CAAmBQ,WAAnB,CAA+B,KAAKC,MAApC,CAAjB,CACD,C,IAMD,cAAYC,KAAZ,CAAmB,8HACXA,KADW,SAJnBD,MAImB,CAJV,eAAsB,IAAnBE,OAAmB,OAAnBA,MAAmB,CAAXC,IAAW,OAAXA,IAAW,CAC7BC,QAAQC,GAAR,CAAY,WAAZ,CAAyBH,MAAzB,CAAiCC,IAAjC,EACD,CAEkB,OA6BnBG,UA7BmB,CA6BN,UAAM,CACjB,MAAKC,QAAL,CAAc,CAACC,WAAY,IAAb,CAAd,EACA,MAAKC,iBAAL,GAAyBd,IAAzB,CAA8B,UAAM,CAClC,MAAKY,QAAL,CAAc,CAACC,WAAY,KAAb,CAAd,EACD,CAFD,EAGD,CAlCkB,CAEjB,MAAKE,KAAL,CAAa,CACXF,WAAY,KADD,CAAb,CAFiB,aAKlB,C,2RAImB3B,mC,SAAdY,K,gBACAkB,G,CAAMC,yC,kCAEHC,MAAMF,GAAN,EACJhB,IADI,CACC,SAACmB,QAAD,QAAcA,UAASC,IAAT,EAAd,EADD,EAEJpB,IAFI,CAEC,SAACqB,YAAD,CAAkB,CAEtB,OAAKT,QAAL,CAAc,CACZU,UAAW,KADC,CAEZC,WAAYF,YAFA,CAAd,CAGG,UAAY,CAEd,CALD,EAOD,CAXI,EAYJG,KAZI,CAYE,SAACC,KAAD,CAAW,CAChBhB,QAAQgB,KAAR,CAAcA,KAAd,EACD,CAdI,C,kGAwBA,CACP,MACE,+BAAC,uBAAD,EAAY,MAAOC,OAAOC,IAA1B,CACA,eACE,8BAAC,2BAAD,EACE,WAAY,KAAKZ,KAAL,CAAWF,UADzB,CAEE,UAAW,KAAKF,UAFlB,EAFF,EAQE,8BAAC,qBAAD,EACE,KAAM,KAAKI,KAAL,CAAWQ,UADnB,CAEE,WAAY,0BAAc,IAAXI,KAAW,OAAXA,IAAW,CACxB,MACE,+BAAC,iBAAD,EAAM,MAAOD,OAAOE,KAApB,EACE,8BAAC,iBAAD,EAAM,MAAOF,OAAOG,KAApB,EAA4BF,KAAKG,KAAjC,CADF,CAEE,8BAAC,kBAAD,EAAO,OAAQ,CAACC,IAAIJ,KAAKK,KAAV,CAAf,CACE,MAAO,CAACC,MAAO,GAAR,CAAaC,OAAQ,GAArB,CADT,EAFF,CAIE,8BAAC,iBAAD,EAAM,MAAOR,OAAOS,IAApB,EAA2BR,KAAKS,OAAhC,CAJF,CADF,CAQD,CAXH,CAYE,aAAc,4BAASC,KAAT,KAAGC,GAAH,OAAGA,EAAH,OAAmBA,IAAGC,QAAH,EAAnB,EAZhB,EARF,CADF,CA2BD,C,kBA9E+BC,gBAAMC,S,kBAAnBvC,I,CAiFrB,GAAMwB,QAASgB,wBAAWC,MAAX,CAAkB,CAC/BhB,KAAM,CACJiB,gBAAiB,SADb,CAEJC,OAAQ,CAFJ,CAGJC,YAAa,SAHT,CAIJC,cAAe,GAJX,CAKJC,aAAc,CALV,CAMJC,aAAc,CACZf,OAAQ,CADI,CAEZD,MAAO,CAFK,CANV,CAUJiB,UAAW,CAVP,CADyB,CAa/BtB,MAAO,CACLuB,WAAY,QADP,CAELC,eAAgB,QAFX,CAGLR,gBAAiB,SAHZ,CAILS,SAAU,CAJL,CAKLR,OAAQ,CALH,CAMLS,QAAS,EANJ,CAOLC,aAAc,EAPT,CAQLT,YAAa,SARR,CASLC,cAAe,GATV,CAULC,aAAc,CAVT,CAWLC,aAAc,CACZf,OAAQ,CADI,CAEZD,MAAO,CAFK,CAXT,CAeLiB,UAAW,CAfN,CAbwB,CA8B/Bf,KAAM,CACJqB,MAAO,SADH,CAEJC,WAAY,KAFR,CA9ByB,CAkC/B5B,MAAO,CACL2B,MAAO,SADF,CAELC,WAAY,MAFP,CAlCwB,CAAlB,CAAf","file":"PrivateFeed.js","sourcesContent":["import React from 'react';\nimport { FlatList, Text, View, StyleSheet, ScrollView, RefreshControl, Image } from 'react-native';\nimport {  NOTIFICATIONS_API } from '../const/Const'\n\n\nasync function registerForPushNotificationsAsync() {\n  const { status: existingStatus } = await Expo.Permissions.getAsync(\n    Expo.Permissions.NOTIFICATIONS\n  );\n  let finalStatus = existingStatus;\n\n  // only ask if permissions have not already been determined, because\n  // iOS won't necessarily prompt the user a second time.\n  if (existingStatus !== 'granted') {\n    // Android remote notification permissions are granted during the app\n    // install, so this will only ask on iOS\n    const { status } = await Expo.Permissions.askAsync(Expo.Permissions.NOTIFICATIONS);\n    finalStatus = status;\n  }\n\n  // Stop here if the user did not grant permissions\n  if (finalStatus !== 'granted') {\n    return;\n  }\n  var token\n  var tk = await Promise\n    .resolve (token = await Expo.Notifications.getExpoPushTokenAsync())\n    .then(x => token);\n  return tk;\n  \n\n}\n\nexport default class Feed extends React.Component {\n\n  componentWillMount() {\n    \n    this.listener = Expo.Notifications.addListener(this.listen);\n  }\n  componentWillUnmount() {\n    this.listener && Expo.Notifications.addListener(this.listen);\n  }\n\n  listen = ({ origin, data }) => {\n    console.log('cool data', origin, data);\n  }\n\n  constructor(props) {\n    super(props);\n    this.state = {\n      refreshing: false,\n    };\n  }\n\n\n  async componentDidMount() {\n    let token = await registerForPushNotificationsAsync();\n    let url = NOTIFICATIONS_API + `/notifications`\n\n    return fetch(url)\n      .then((response) => response.json())\n      .then((responseJson) => {\n\n        this.setState({\n          isLoading: false,\n          dataSource: responseJson,\n        }, function () {\n\n        });\n\n      })\n      .catch((error) => {\n        console.error(error);\n      });\n  }\n\n  _onRefresh = () => {\n    this.setState({refreshing: true});\n    this.componentDidMount().then(() => {\n      this.setState({refreshing: false});\n    });\n  }\n\n  render() {\n    return (\n      <ScrollView style={styles.item}\n      refreshControl={\n        <RefreshControl\n          refreshing={this.state.refreshing}\n          onRefresh={this._onRefresh}\n        />\n      }\n      >\n        <FlatList\n          data={this.state.dataSource}\n          renderItem={({ item }) => {\n            return (\n              <View style={styles.item2}>\n                <Text style={styles.text1}>{item.title}</Text>\n                <Image source={{uri:item.image}}\n                  style={{width: 400, height: 200}} />\n                <Text style={styles.text}>{item.message}</Text>\n              </View>\n            );\n          }}\n          keyExtractor={({ id }, index) => id.toString()}\n          \n        />\n        \n      </ScrollView>\n    );\n  }\n}\n\nconst styles = StyleSheet.create({\n  item: {\n    backgroundColor: \"#ffffff\",\n    margin: 4,\n    shadowColor: \"#000000\",\n    shadowOpacity: 0.8,\n    shadowRadius: 2,\n    shadowOffset: {\n      height: 1,\n      width: 1\n    },\n    elevation: 4\n  },\n  item2: {\n    alignItems: \"center\",\n    justifyContent: 'center',\n    backgroundColor: \"#ffffff\",\n    flexGrow: 1,\n    margin: 4,\n    padding: 20,\n    borderRadius: 10,\n    shadowColor: \"#000000\",\n    shadowOpacity: 0.8,\n    shadowRadius: 2,\n    shadowOffset: {\n      height: 1,\n      width: 1\n    },\n    elevation: 4\n  },\n  text: {\n    color: \"#540b71\",\n    fontWeight: '100'\n  },\n  text1: {\n    color: \"#540b71\",\n    fontWeight: 'bold',\n  }\n});\n"]}